import math
import random
import copy
from Grasshopper import DataTree as tree
#import ghpythonlib.components as ghcomp
#import ghpythonlib.parallel
#import Rhino.Geometry as geometry

## GH Global Output Arrays


objType = [];
objX = [];
objY = [];
objL = [];
objH = [];

print Adjacencies;
print Adjacencies.BranchCount;


#Alen = Adjacencies.BranchCount;
#for i in range(Alen):
#    path = Adjacencies.Path[i];
#    print Adjacencies.Branch[path];

## PARAMETERS ######################################################################################

#DECAY = 1;                          # Decay length for fields. Increase to extend influence of element fields
DECAY = decay;                          # Decay length for fields. Increase to extend influence of element fields

#CIRCULATION_BLOCK = 1;              # Amount of circulation generated by an object
CIRCULATION_BLOCK = int(C_Block);              # Amount of circulation generated by an object
#CIRCULATION_MAX_VALUE = 0.3;        # Maximum blocking value
CIRCULATION_MAX_VALUE = C_Power;        # Maximum blocking value
OBSTACLE_MAX_VALUE = float('inf');
showDisplay = False;                 # Toggle to False in Grasshopper
#L = 65;                             # Length of Floorplate
#H = 110;                            # Height of Floorplate
L = int(X_dim);                             # Length of Floorplate
H = int(Y_dim);                            # Height of Floorplate


#    Office(0), WS(1), CL(2), CS(3), PS(4), E(5), S(6), R(7)
A = [
    [-.5, 0.7, 0.9, 0.6, 0.3, 0.0, 0.0, 0.0],
    [0.7, 0.5, 0.7, 0.9, 0.8, 0.0, 0.0, 0.0],
    [0.9, 0.7,-0.8, 0.5, 0.8, 0.8, 0.8, 0.4],
    [0.6, 0.9, 0.5, 0.2, 0.1, 0.6, 0.6, 0.0],
    [0.3, 0.8, 0.8, 0.1, 0.0, 0.0, 0.0, 0.0],
    [0.0, 0.0, 0.8, 0.6, 0.0, 0.0, 1.0, 0.6],
    [0.0, 0.0, 0.8, 0.6, 0.0, 1.0, 0.0, 0.7],
    [0.0, 0.0, 0.4, 0.0, 0.0, 0.6, 0.7, 0.0]
];
lhArray = [
            [9, 11],
            [6, 8],
            [12, 17],
            [10, 10],
            [7, 7],
            [14, 17],
            [11, 18],
            [19, 13]];
daylightAdj = [0.6, 0.9, 0.5, 0.4, 0, 0, 0, 0];
centerFieldAdj = [0, 0, 0, 0, .1, .5, .5, .5];
numElements = len(A[0]);
####################################################################################################
def runScript():
    env = Environment(H,L);
    hm = HeatMap(env, numElements);
    hm.addDaylightField([2, 3]);
    hm.addCenterField();

    numLargeConfRooms = 3;
    # elemsToPlace = [[0, 0, 0, 0]];
    elemsToPlace = [[lhArray[7][0], lhArray[7][1], 7, 1],
                    [lhArray[5][0], lhArray[5][1], 5, 1],
                    [lhArray[6][0], lhArray[6][1], 6, 1]];
    elemsToPlace.extend(calculateElementOrder(numLargeConfRooms, [10, 40, 0, 6, 3, 0, 0, 0]));
    for e in elemsToPlace:
        scaleVector = A[e[2]];
        for i in range(int(e[3])):
            [y,x] = hm.maximizeConvolvedHeatMap(e[0], e[1], e[2]);
            print e[2], x, y;
            ob = Obstacle(x, y, e[0], e[1], e[2]);
            
            objType.append(ob.obType);
            objX.append(ob.x);
            objY.append(ob.y);
            objL.append(ob.l);
            objH.append(ob.h);
            
            hm.populateField([ob]);
            hm.addCirculation(ob);
    print hm.env.grid[10][0];
#    if(showDisplay):
#        hm.show([1]*numElements);

## Creates the ordering array for element placement
def calculateElementOrder(numLargeConfRooms, numElems):
    ordering = [];
    for i in range(numLargeConfRooms):
        ordering.append([lhArray[2][0], lhArray[2][1], 2, 1]);
        for elemType,numLeft in enumerate(numElems):
            n = min(numLeft, numLeft/numLargeConfRooms+1);
            ordering.append([lhArray[elemType][0], lhArray[elemType][1], elemType, n]);
    return ordering;

## Environment object
class Environment:
    def __init__(self, xlen, ylen):
        self.grid = [];
        self.xlen = xlen;
        self.ylen = ylen;
        for i in range(ylen):
            self.grid.append([]);
            for j in range(xlen):
                self.grid[i].append({});
    def get(self, i, j):
        return self.grid[i][j];
    def put(self, i, j, elem):
        self.grid[i][j] = elem;

## Instantiates a heat map which contains field info
class HeatMap:
    def __init__(self, env, numElements):
        self.env = env;
        self.initializeFields_(numElements);

    ## Initializes the fields (no obstacles yet)
    def initializeFields_(self, numElements):
        emptyField = {};
        for i in range(numElements):
            emptyField[i] = 0;
        for y in range(self.env.ylen):
            for x in range(self.env.xlen):
                self.env.put(y,x, {'field':copy.copy(emptyField), 'daylightfield': 0, 'centerfield': 0, 'occupied': False, 'ofield': 0});

    # Creates field values for the obstacles in the field of the heat map
    def populateField(self, obs):
        for y in range(self.env.ylen):
            for x in range(self.env.xlen):
                for ob in obs:
                    fields = calculateFields(x,y,ob);
                    self.env.grid[y][x]['field'][ob.obType] += fields[0];
                    self.env.grid[y][x]['ofield'] += fields[1];
        for yOb in range(ob.y, min(ob.y+ob.h, self.env.ylen)):
            for xOb in range(ob.x, min(ob.x+ob.l, self.env.xlen)):
                self.env.grid[yOb][xOb]['occupied'] = True;

    # Creates the field values for circulation in the field of the heat map
    def addCirculation(self, ob):
        # Four sides
        for y in range(ob.y+ob.h,min(ob.y+ob.h+CIRCULATION_BLOCK, self.env.ylen)):
            for x in range(self.env.xlen):
                d = abs(ob.x+0.5*ob.l-x)+1;
                self.env.grid[y][x]['ofield'] -= CIRCULATION_MAX_VALUE/d;
        for y in range(max(ob.y-CIRCULATION_BLOCK, 0), ob.y):
            for x in range(self.env.xlen):
                d = abs(ob.x+0.5*ob.l-x)+1;
                self.env.grid[y][x]['ofield'] -= CIRCULATION_MAX_VALUE/d;
        for y in range(self.env.ylen):
            for x in range(ob.x+ob.l, min(ob.x+ob.l+CIRCULATION_BLOCK, self.env.xlen)):
                d = abs(ob.y+0.5*ob.h-y)+1;
                self.env.grid[y][x]['ofield'] -= CIRCULATION_MAX_VALUE/d;
        for y in range(self.env.ylen):
            for x in range(max(ob.x-CIRCULATION_BLOCK, 0), ob.x):
                d = abs(ob.y+0.5*ob.h-y)+1;
                self.env.grid[y][x]['ofield'] -= CIRCULATION_MAX_VALUE/d;

    # Adds the Daylight Field to the floor plate
    def addDaylightField(self, sides):
        xl = self.env.xlen;
        yl = self.env.ylen;
        for s in sides:
            if(s == 0):
                for x in range(xl):
                    for y in range(yl):
                        curField = self.env.grid[y][x]['daylightfield'];
                        self.env.grid[y][x]['daylightfield'] = max(math.exp(-(y-yl)/float(yl)), curField);
            if(s == 1):
                for x in range(xl):
                    for y in range(yl):
                        curField = self.env.grid[y][x]['daylightfield'];
                        self.env.grid[y][x]['daylightfield'] = max(math.exp(-(x-xl)/float(xl)), curField);
            if(s == 2):
                for x in range(xl):
                    for y in range(yl):
                        curField = self.env.grid[y][x]['daylightfield'];
                        self.env.grid[y][x]['daylightfield'] = max(math.exp(-y/float(yl)), curField);
            if(s == 3):
                for x in range(xl):
                    for y in range(yl):
                        curField = self.env.grid[y][x]['daylightfield'];
                        self.env.grid[y][x]['daylightfield'] = max(math.exp(-x/float(xl)), curField);

    # Adds the center field to the floor plate
    def addCenterField(self):
        xl = self.env.xlen;
        yl = self.env.ylen;
        for y in range(yl):
            for x in range(xl):
                self.env.grid[y][x]['centerfield'] = math.exp(-(((x-0.5*xl)/xl)**2+((y-0.5*yl)/yl)**2));

    # Displays the heat map
    def show(self, scaleVector):
        m = self.returnObstaclesMap();
        #m = self.returnHeatMapData(scaleVector);
        plt.imshow(m, cmap = 'hot');
        plt.xticks(numrange(0, self.env.xlen, 5));
        plt.yticks(numrange(0, self.env.ylen, 5));
        plt.grid(True);
        plt.show();

    # Returns the Heat Map Data
    def returnHeatMapData(self, obType):
        m = [];
        scaleVector = A[obType];
        for i in range(self.env.ylen):
            m.append([]);
            for j in range(self.env.xlen):
                m[i].append(vectorProduct(self.getFieldVector(i, j), scaleVector)+self.env.grid[i][j]['ofield']
                    +daylightAdj[obType]*self.env.grid[i][j]['daylightfield']
                    +centerFieldAdj[obType]*self.env.grid[i][j]['centerfield']);
        return m;

    # Returns the Heat Map with Obstacles
    def returnObstaclesMap(self):
        m = [];
        for i in range(self.env.ylen):
            m.append([]);
            for j in range(self.env.xlen):
                if(self.env.grid[i][j]['occupied']):
                    #m[i].append(self.env.grid[i][j]['ofield']);
                    m[i].append(1);
                else:
                    m[i].append(0);
        return m;

    # Returns the field values as a list
    def getFieldVector(self, y, x):
        f = self.env.get(y,x)['field'];
        return f.values();

    # Returns the (x,y) point that maximizes a convolved map for a convolving rectangle of length l
    # and height h
    def maximizeConvolvedHeatMap(self, l, h, obType):
        maxVal = -float('inf');
        maxInds = [-1, -1];
        m = self.returnHeatMapData(obType);
        for x in range(self.env.xlen-l+1):
            for y in range(self.env.ylen-h+1):
                val = 0;
                for xl in range(x, min(x+l, self.env.xlen)):
                    for yl in range(y, min(y+h, self.env.ylen)):
                        val += m[yl][xl];
                if(val >= maxVal):
                    maxVal = val;
                    maxInds = [y, x];
        return maxInds;


## Obstacle Object
class Obstacle:
    def __init__(self, x, y, l, h, obType):
        self.obType = obType;
        self.x = x;
        self.y = y;
        self.l = l;
        self.h = h;
        self.THRESH = (l+h);
        self.SIZE = max(0.5*l,0.5*h);

## Calculates the field values via a distance metric
def calculateFields(x, y, ob):
    field = 0;
    ofield = 0;
    if(outsideObstacle(x, y, ob)):
        d = maxdistance([x,y],[ob.x+0.5*ob.l, ob.y+0.5*ob.h]);
        if(d < ob.THRESH):
            field = math.exp(-d/float(DECAY));
        else:
            field = 0;
    else:
        ofield = -OBSTACLE_MAX_VALUE;
    return [field, ofield];

## Calculates whether a point is outside a rectangular obstacle
def outsideObstacle(x, y, ob):
    result = (x >= ob.x) and (x < ob.x+ob.l) and (y >= ob.y) and (y < ob.y+ob.h);
    return not(result);

## Infinity Norm
def maxdistance(p0, p1):
    return max(abs(p0[0]-p1[0]), abs(p0[1]-p1[1]));

## Square distance
def sqdistance(p0, p1):
    return (p0[0] - p1[0])**2 + (p0[1] - p1[1])**2;

## Vector dot Product
def vectorProduct(v1, v2):
    tot = 0;
    for i in range(len(v1)):
        tot += v1[i]*v2[i];
    return tot;

## Range (to replace np arange)
def numrange(st, end, delta):
    x = [];
    i = st;
    while (i < end):
        x.append(i);
        i += delta;
    return x;

if __name__ == '__main__':
    runScript();
    
    Type = objType;
    Xpos = objX;
    Ypos = objY;